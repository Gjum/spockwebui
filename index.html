<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Spock UI</title>
    <style type="text/css">
        .guiLine {
            fill: none;
        }

        .lineGuide {
            stroke: hsl(0, 0%, 40%);;
            stroke-width: 3px;
        }

        .lineHighlight {
            stroke: hsl(211, 100%, 54%);;
            stroke-width: 5px;
        }

        .guiShape {
            stroke: none;
        }

        .shapeGuide {
            fill: hsl(0, 0%, 40%);;
        }

        .shapeHighlight {
            fill: hsl(211, 100%, 54%);;
        }

        body {
            background-color: #333639;
            color: #bebebe;
        }
    </style>
    <script type="text/javascript">
    var svgNS = "http://www.w3.org/2000/svg";

    function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
        var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
        return {
            x: centerX + (radius * Math.cos(angleInRadians)),
            y: centerY + (radius * Math.sin(angleInRadians))
        };
    }

    function describeArc(x, y, radius, startAngle, endAngle) {
        var start = polarToCartesian(x, y, radius, startAngle);
        var end = polarToCartesian(x, y, radius, endAngle);
        var deltaAngle = (endAngle - startAngle);
        var largeArc = Math.abs(deltaAngle) % 360 >= 180 ? "1" : "0";
        var arcSweep = deltaAngle >= 0 ? "1" : "0";
        return [
            "M", start.x, start.y,
            "A", radius, radius, 0, largeArc, arcSweep, end.x, end.y
        ].join(" ");
    }

    function interpolate(progress, from, to) {
        if (progress < 0 || 1 < progress)
            console.warn("Interpolating out of range:", progress);
        return from * (1 - progress) + to * progress;
    }

    function setObjAttr(attr, val) {
        this[attr] = val;
        return this;
    }

    function makeSvg(left, top, width, height) {
        var svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("width", width + "px");
        svg.setAttribute("height", height + "px");
        svg.setAttribute("viewBox", [left, top, width, height].join(" "));
        return svg;
    }

    function createOrGetGlobalSvg(id) {
        var svg = document.getElementById(id);
        if (svg) return svg;
        // else: not found, create

        svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("style", "visible:false;position:absolute;width:0;height:0");
        document.body.appendChild(svg);

        return svg;
    }

    function setBlur(element, blurId) {
        blurId = blurId || "globalSvgBlurFilter";
        var filterUrl = "url(#" + blurId + ")";

        if (!document.getElementById(blurId)) {
            var blur = document.createElementNS(svgNS, "feGaussianBlur");
            blur.setAttribute("in", "StrokePaint");
            blur.setAttribute("stdDeviation", "2");

            var filter = document.createElementNS(svgNS, "filter");
            filter.setAttribute("id", blurId);
            filter.appendChild(blur);

            createOrGetGlobalSvg().appendChild(filter);
        }

        element.setAttribute("filter", filterUrl);
        return filterUrl;
    }

    function Gauge(id) {
        this.value = 0;
        this.minVal = 0;
        this.maxVal = 1;
        this.radius = 50;
        this.startAngle = 240;
        this.endAngle = 480;
        this.blur = true;
        // TODO refactor animation stuff into helper
        this.animDuration = 500;
        var targetDashOffset = null;
        var animStartDashOffset = null;
        var animation = null;

        var arcPixel = 0;
        var svgElement = null;
        var valueElement = null;

        this.set = setObjAttr;
        var self = this;

        this.setValue = function (newVal, immediate) {
            if (!valueElement) {
                console.warn("Gauge", id, "setting value before adding to DOM");
                return;
            }

            if (animation) {
                // calculate the current attribute value,
                // because the DOM does not store it
                // TODO can we get the current attribute value from the animation object?
                var progress = animation.currentTime / self.animDuration;
                animation.finish();
                animation = null;
                animStartDashOffset = interpolate(progress, animStartDashOffset, targetDashOffset);
                // TODO cubic spline?
            }
            else animStartDashOffset = valueElement.getAttribute("stroke-dashoffset");

            if (newVal < self.minVal) {
                console.warn("Gauge", id, "got too small value", newVal, "<", self.minVal);
                newVal = self.minVal;
            }
            else if (newVal > self.maxVal) {
                console.warn("Gauge", id, "got too large value", newVal, ">", self.maxVal);
                newVal = self.maxVal;
            }

            self.value = newVal;

            targetDashOffset = getDashOffset(self.value);

            if (!immediate) {
                animation = valueElement.animate([
                    {strokeDashoffset: animStartDashOffset},
                    {strokeDashoffset: targetDashOffset}
                ], self.animDuration);
            }

            // after the animation is done, the property reverts to
            // its previous state, so we still have to set the target value
            valueElement.setAttribute("stroke-dashoffset", targetDashOffset);

            return this;
        };

        this.addToElement = function (element) {
            element.appendChild(this.getElement());
            return this;
        };

        this.getElement = function () {
            if (!svgElement) createElements();
            return svgElement;
        };

        function createElements() {
            if (valueElement) {
                console.warn("Gauge", id, "was already created");
                return svgElement;
            }

            var sizeAngle = self.endAngle - self.startAngle;
            arcPixel = Math.abs(6.283 * self.radius * sizeAngle / 360);

            var dasharray = [0, arcPixel, arcPixel, 0].join(" ");
            var d = describeArc(0, 0, self.radius, self.startAngle, self.endAngle);

            valueElement = document.createElementNS(svgNS, "path");
            valueElement.setAttribute("class", "guiLine lineHighlight");
            valueElement.setAttribute("d", d);
            // The value is displayed using a dashed pattern,
            // one dash (in the negaive direction) being
            // 100% color followed by 100% transparency.
            // This way the dash offset (and thus the visible arc length)
            // can be animated, while the arc endpoint coordinates can not
            // (well, they can be animated linearly, which looks odd).
            valueElement.setAttribute("stroke-dasharray", dasharray);
            valueElement.setAttribute("stroke-dashoffset", getDashOffset(self.value));
            if (self.blur) setBlur(valueElement);

            var outlineElement = document.createElementNS(svgNS, "path");
            outlineElement.setAttribute("class", "guiLine lineGuide");
            outlineElement.setAttribute("d", d);

            var maxBottomAngle = Math.max(self.startAngle, self.endAngle);
            var bottomPart = polarToCartesian(0, 0, self.radius, maxBottomAngle).y;

            var padding = 10;
            var boxRadius = self.radius + padding;
            var left = -boxRadius;
            var top = -boxRadius;
            var width = 2 * boxRadius;
            var height = boxRadius + padding + bottomPart;

            svgElement = makeSvg(left, top, width, height);
            svgElement.setAttribute("id", id);
            svgElement.appendChild(outlineElement);
            svgElement.appendChild(valueElement);

            return svgElement;
        }

        function getDashOffset(val) {
            // can be out of range, because default value is 0
            // user input is checked and logged in setValue()
            if (val < self.minVal) val = self.minVal;
            else if (val > self.maxVal) val = self.maxVal;

            var valRange = self.maxVal - self.minVal;
            var valueFraction = (val - self.minVal) / valRange;

            return -arcPixel * valueFraction;
        }

    }

    function init() {


    }
    </script>
</head>
<body onload="init()">
<script>
    var firstGauge = new Gauge("First")
            .set("minVal", 20)
            .set("maxVal", 40)
            .addToElement(document.body)
            .setValue(40, "immediate")
            .setValue(20);
    window.setTimeout(firstGauge.setValue, 1000, 30);
</script>
<script>
    var reversedGauge = new Gauge("Reversed")
            .set("radius", 20)
            .set("startAngle", 480)
            .set("endAngle", 240)
            .addToElement(document.body)
            .setValue(.2, "immediate")
            .setValue(.8);

    // var t = 1;
    // window.setTimeout(function () {
    //     reversedGauge.setValue(.8, "immediate")
    // }, 1000 * t++);
    // window.setTimeout(function () {
    //     reversedGauge.setValue(0)
    // }, 1000 * t++);
    // window.setTimeout(function () {
    //     reversedGauge.setValue(1)
    // }, 1000 * t++);

    // var counter = 0;
    // var inter = (1 - Math.abs((counter % 100) / 50 - 1))
    // counter += 1
</script>

<br />
expected final svgs for comparison:
<br />

<svg width="120px" height="95" viewBox="-60 -60 120 95">
    <path class="guiLine lineGuide"
          d="M -43.30127018922194 24.999999999999996 A 50 50 0 1 1 43.30127018922195 24.999999999999964"></path>
    <path class="guiLine lineHighlight"
          d="M -43.30127018922194 24.999999999999996 A 50 50 0 0 1 -9.184850993605149e-15 -50"
          filter="url(#globalSvgBlurFilter)"></path>
</svg>
<svg width="60px" height="50" viewBox="-30 -30 60 50">
    <path class="guiLine lineGuide"
          d="M 17.32050807568878 9.999999999999986 A 20 20 0 1 0 -17.320508075688775 9.999999999999998"></path>
    <path class="guiLine lineHighlight"
          d="M 17.32050807568878 9.999999999999986 A 20 20 0 1 0 -19.02113032590307 -6.180339887498954"
          filter="url(#globalSvgBlurFilter)"></path>
</svg>

<br/><!-- experiments -->

<!-- TODO line graph -->
<svg width="220px" height="120px" viewBox="-10 -10 220 120" style="border:1px dotted gray">
    <g class="guiShape shapeGuide">
        <polyline class="guiLine lineGuide" points="0,20 50,100 100,0 150,70 200,20"></polyline>
        <circle r="6" cx="0" cy="20"></circle>
        <circle r="6" cx="50" cy="100"></circle>
        <circle r="6" cx="100" cy="0"></circle>
        <circle r="6" cx="150" cy="70"></circle>
        <circle r="6" cx="200" cy="20"></circle>
    </g>
    <g class="guiShape shapeHighlight" filter="url(#globalSvgBlurFilter)">
        <polyline class="guiLine lineHighlight" points="0,20 50,100 100,0 150,70 200,20"></polyline>
        <circle r="6" cx="0" cy="20"></circle>
        <circle r="6" cx="50" cy="100"></circle>
        <circle r="6" cx="100" cy="0"></circle>
        <circle r="6" cx="150" cy="70"></circle>
        <circle r="6" cx="200" cy="20"></circle>
    </g>
</svg>

<!-- TODO histogram -->
<!-- TODO use rectangles? -->
<svg width="220px" height="120px" viewBox="-10 -10 220 120" style="border:1px dotted gray">
    <g class="guiLine lineGuide">
        <line x1="0" x2="0" y1="100" y2="70"></line>
        <line x1="50" x2="50" y1="100" y2="20"></line>
        <line x1="100" x2="100" y1="100" y2="30"></line>
        <line x1="150" x2="150" y1="100" y2="60"></line>
        <line x1="200" x2="200" y1="100" y2="50"></line>
    </g>
    <g class="guiShape shapeGuide">
        <circle r="6" cx="0" cy="70"></circle>
        <circle r="6" cx="50" cy="20"></circle>
        <circle r="6" cx="100" cy="30"></circle>
        <circle r="6" cx="150" cy="60"></circle>
        <circle r="6" cx="200" cy="50"></circle>
    </g>
    <g class="guiShape shapeHighlight" filter="url(#globalSvgBlurFilter)">
        <circle r="6" cx="0" cy="70"></circle>
        <circle r="6" cx="50" cy="20"></circle>
        <circle r="6" cx="100" cy="30"></circle>
        <circle r="6" cx="150" cy="60"></circle>
        <circle r="6" cx="200" cy="50"></circle>
    </g>
    <g filter="url(#globalSvgBlurFilter)">
        <!-- TODO blurred histogram line is invisible ?! -->
        <line class="guiLine lineHighlight" filter="url(#globalSvgBlurFilter)"
              x1="100" x2="100" y1="100" y2="70"></line>
    </g>
</svg>

<br/><!-- stroke dash animation -->

<svg width="120px" height="95" viewBox="-60 -60 120 95">
    <path class="guiLine lineGuide" d="M -43.3 25 A 50 50 0 1 1 43.3 25"></path>
    <path class="guiLine lineHighlight" d="M -43.3 25 A 50 50 0 1 1 43.3 25"
          stroke-dasharray="0 210 210 0"
          stroke-dashoffset="0"
          id="strokegauge" filter="url(#globalSvgBlurFilter)"></path>
</svg>
<br/>
<label>set stroke offset<input type="range" value="0" oninput="
var val = -2/3 * 6.283*50 * this.value/100;
this.nextSibling.textContent = val;
document.getElementById('strokegauge').setAttribute('stroke-dashoffset', val);
"/>0</label>
<br/>
<label>set global blur<input type="range" step="20" width="400" value="0" oninput="
var val = 5*this.value/100;
this.nextSibling.textContent = val;
document.getElementById('globalSvgBlurFilter').firstChild.setAttribute('stdDeviation', val);
"/>0</label>

<br/>

<script>
    var sliderGauge = new Gauge("sliderGauge")
            .addToElement(document.body)
            .setValue(.5);
</script>
<br/>
<label>set gauge value<input type="range" oninput="
var val = this.value*.01;
this.nextSibling.textContent = val;
sliderGauge.setValue(val);
"/>0</label>

<br/>

<script>
    var webAnimGauge = new Gauge("webAnimation")
            .addToElement(document.body)
            .setValue(1, "immediate");
    var valueElement = webAnimGauge.getElement().childNodes[1];
    valueElement.animate([
        {strokeDashoffset: valueElement.getAttribute("stroke-dashoffset")},
        {strokeDashoffset: 0}
    ], 2000);
    valueElement.setAttribute("stroke-dashoffset", 0);
</script>
animated using web-animations

</body>
</html>
